---
title: Условные конструкции и циклы
---

> [!WARNING]
> 
> Для переменных, объявленных с помощью `let` или `const`, существует область видимости внутри условных конструкций `if`, `switch` и циклов `for`, `while`!
> 
> ```js
> if (true) {
>   let blockVar = 'Я в блоке';
>   var functionVar = 'Я в функции или глобальной области';
> }
> 
> console.log(functionVar); // доступно
> console.log(blockVar); // ошибка: blockVar is not defined
> ```

## Условные конструкции

### `if..else`

```js
let age = 20;
if (age < 18) {
	console.log("Ты ещё мал!");
} else if (age < 21) {
	console.log("Скоро сможешь всё!");
} else {
	console.log("Добро пожаловать!");
}
```

> [!NOTE]
> 
> **Преобразование выражения в `boolean`**
> 
> Конструкция `if..else` преобразовывает результат выражения в скобках в `boolean`.
> Подробнее о преобразовании типов можно узнать [[3. Преобразование типов|тут]].
> ```js
> if (0) {
> 	// код не будет выполнен
> }
> 
> if (1) {
> 	// код будет выполнен
> }
> ```

### `switch`

```js
let color = "green";
switch (color) {
	case "red": // if (color === "red")
		console.log("Стоп!");
		break; // ставим чтобы избежать выполнения других условий
	case "yellow": // if (color === "yellow")
		console.log("Готовься!");
		break;
	case "green": // if (color === "green")
		console.log("Езжай!");
		break;
	// можно использовать выражения как аргумент для 'case'
	case 5 + 10: // if (color === 5 + 10)
		console.log("Что не так со светофором?");
		break;
	default: // условие по умолчанию
		console.log("Неизвестный сигнал.");
		// здесь нет смысла ставить "break" т.к. это последний блок
}
```

> [!NOTE]
> 
> В `switch` можно не использовать `break`, если после `case` не нужно выполнять другие операции. Однако, если еще осталось несколько операций, важно ставить `break`, чтобы избежать выполнения других `case`.


> [!NOTE]
> 
> **Типы данных в `switch`**
> 
> `switch` работает с выражениями любого типа и использует строгую проверку типов (`===`). Это означает, что для правильного совпадения значения и типа данных в `case` должны точно совпасть.
> 
> ```js
> let value = "10";
> 
> switch (value) {
>   case 10:
>     console.log("Число 10");
>     break;
>   case "10":
>     console.log("Строка '10'");
>     break;
>   default:
>     console.log("Не совпало");
> }
> ```
> 
> В этом примере, несмотря на то, что строка `"10"` и число `10` выглядят одинаково, они **не совпадают**, потому что типы разные (строка и число).

> [!NOTE]
> 
> **Использование выражений в `switch`**
> 
> В `switch` можно использовать выражения для динамического сравнения значений.
> 
> - **Выражения с вычислениями**
> ```js
> let x = 10;
> let y = 5;
> 
> switch (x - y) {
>   case 1:
>     console.log("Разница 1");
>     break;
>   case 5:
>     console.log("Разница 5");
>     break;
>   default:
>     console.log("Неизвестная разница");
> }
> ```
> - **Логические выражения**  
> Использование `switch` с логическими условиями позволяет проверять несколько выражений в одном блоке.
> ```js
> let x = 5;
> 
> switch (true) {
>   case (x > 0 && x < 10):
>     console.log("Число больше 0 и меньше 10");
>     break;
>   case (x === 5):
>     console.log("Число равно 5");
>     break;
>   default:
>     console.log("Число не соответствует ни одному условию");
> }
> ```
> - **Использование функций**  
> Можно передать результат работы функции в `switch`, например, при сравнении преобразованных строк.
> ```js
> function getColorCode(color) {
>   switch (color.toLowerCase()) {
>     case "red":
>       return "#FF0000";
>     case "green":
>       return "#00FF00";
>     case "blue":
>       return "#0000FF";
>     default:
>       return "#FFFFFF";  // цвет по умолчанию
>   }
> }
> 
> console.log(getColorCode("green")); // #00FF00
> ```

> [!NOTE]
> 
> **Использование объектов и массивов в `switch`**
> 
> Хотя объекты и массивы можно использовать в `switch`, следует помнить, что они сравниваются по ссылке, а не по значению.
> 
> **Пример с объектом:**
> ```js
> const obj1 = { id: 1 };
> const obj2 = { id: 1 };
> 
> switch (obj1) {
>   case obj2:
>     console.log("Объекты равны");
>     break;
>   default:
>     console.log("Объекты не равны");
> }
> ```
> Несмотря на то, что объекты имеют одинаковые значения, они не равны, потому что сравнение происходит по ссылке.
> 
> **Пример с массивами:**
> ```js
> const arr1 = [1, 2, 3];
> const arr2 = [1, 2, 3];
> 
> switch (arr1) {
>   case arr2:
>     console.log("Массивы равны");
>     break;
>   default:
>     console.log("Массивы не равны");
> }
> ```
> Аналогично, массивы тоже сравниваются по ссылке, и результат будет "Массивы не равны", даже если они содержат одинаковые элементы.

## Циклы

### `while`

```js
let i = 1;
while (i <= 5) {
  console.log("Итерация No. ", i);
  i++;
}
console.log("Конец работы");
```

### `do..while`

```js
let x = 10;
do {
  console.log("Это выполнится хотя бы 1 раз!");
  x--;
} while (x > 10);
```

> [!NOTE]
> 
> В отличие от `while`, цикл `do..while` выполняется хотя бы один раз, даже если условие изначально не выполнено.

### `for`

> [!TIP]
> 
> `for ( инициализация_счетчика; условие; изменение_счетчика ) { тело }`

```js
// cтандартный цикл с инициализацией, условием и изменением
for (let i = 1; i <= 5; i++) {
  console.log("Итерация No. ", i);
}
console.log("Конец работы");
```

### `for..of`

> [!NOTE]
> 
> Цикл `for..of` используется для перебора элементов массива, строк и других итерируемых объектов (например, `Map`, `Set`).

```js
const text = "Hello";
// перебор символов в строке "Hello"
for(char of text){
     console.log(char); // "h", "e", "l", "l", "o"
}
```

### `for..in`

> [!NOTE]
> 
> Цикл `for..in` используется для перебора свойств объекта, включая унаследованные свойства, а также индексы массива.

```js
const person = { name: "John", age: 30 };
// перебор свойств объекта person
for (let key in person) {
    console.log(key); // "name", "age"
    console.log(person[key]); // "John", 30
}
```

### `break`

> [!NOTE]
> 
> `break` полностью прекращает выполнение цикла.
> В примере ниже цикл будет остановлен, как только `i` будет равен `5`.

```js
for (let i = 1; i <= 10; i++) {
  if (i === 5) break; // остановит цикл, когда i станет 5
  console.log(i);
}
```
### `continue`

> [!NOTE]
> 
> `continue` пропускает текущую итерацию цикла и переходит к следующей.
> В примере ниже цифра `3` не будет выведена.

```js
for (let i = 1; i <= 5; i++) {
  if (i === 3) continue; // пропустит 3
  console.log(i);
}
```

