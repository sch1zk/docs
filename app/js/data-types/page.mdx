---
title: Типы данных
---

## Оператор `typeof`

Используется для получения типа переменной.

```js
const id = "45";
console.log(typeof id); // string
```

## `number`

Числа, как целые, так и дробные.

```js
const x = 45; // целое число
const y = 123.897; // дробное число (с плавающей точкой/запятой)
const z = -0.123; // отрицательное дробное число
// для увеличения читабельности в качестве разделителя между разрядами можно использовать _
const num1 = 1234567890;
const num2 = 12_3456_7890; // число равное num1
```

## `bigint`

Предназначен для работы с большими **целыми** числами, которые выходят за пределы диапазона типа `number`.

```js
const num = 9007199254740991 // число выходит запределы диапазона типа "number"
```

## `string`

Строки (текст).

```js
const user = "Tom"; // используем двойные кавычки
const company = 'Microsoft'; // используем одинарные кавычки
const language = `JavaScript`; // используем косые кавычки
// экранируем кавычки с помощью \ чтобы они корректно отображались
const company = "Бюро \"Рога и копыта\"";
// используем переход на след. строку \n
// используем табуляцию \t
const text = "Hello Worlf\nHello\tUser";
```

> [!NOTE]
> 
> **Шаблонные строки (Template Literals)**
> - Позволяют вставлять переменные и выражения прямо в строку с использованием `${}`.
> - Поддерживают многострочные строки.
> ```js
> // объявляем переменные
> const user = "Tom";
> const age = 37;
> const isMarried = false;
> // с помощью косых кавычек можем вставлять данные в строку
> const text = `Name: ${user}  Age: ${age}  IsMarried: ${isMarried}`;
> console.log(text); // Name: Tom  Age: 37  IsMarried: false
> ```
> ```js
> // шаблонные строки также позволяют работать с многострочным текстом
> const text = 
> `Мы все учились понемногу
> Чему-нибудь и как-нибудь,
> Так воспитаньем, слава богу,
> У нас немудрено блеснуть.`;
> console.log(text);
> ```

## `boolean`

Логические значения.

```js
const isAlive = true; // правда
const isDead = false; // ложь
```

## `null`

Пустое значение.

```js
let email;
console.log(email); // undefined
email = null;
console.log(email); // null
```

> [!TIP]
> 
> **В чем разница с `undefined`?**
> 
> - `undefined` - переменная не получила значение. Это означает, что переменная объявлена, но ей не присвоено никакое значение.
> - `null` - это осознанное присваивание значения "пусто". Это как бы явное указание, что переменная не содержит никакой информации.

## `undefined`

Переменная объявлена, но не имеет значения.

```js
let email;
console.log(email); // undefined
```

> [!TIP]
> 
> **Для чего же этот тип нужен**
> 
> - `undefined` означает, что переменная была объявлена, но еще не была инициализирована значением.
> 
> Можно использовать это, например, для проверки инициализации переменной:
> ```js
> let x; // переменная объявлена, но не инициализирована
> if (x === undefined) {
> 	console.log("Переменная не инициализирована!");
> } else {
> 	console.log("Переменная имеет значение:", x);
> }

## `object`

Сложные структуры данных, такие как массивы или [[9. Объекты|объекты]].

```js
const user = {}; // пустой объект
const user = {name: "Tom", age: 24}; // объект с двумя свойствами
console.log(user.name); // выводим свойство "name" объекта "user"
```

## Мутируемые и немутируемые типы

В JavaScript данные делятся на два типа: **примитивные типы** и **объекты**. Разница между ними заключается в **мутируемости** данных - возможности изменять их значения.

> [!WARNING]
> 
> **Важно помнить**
> 
> Примитивы - **немутируемые**: изменения значений создают новое значение.
> Объекты - **мутируемые**: изменения внутри объекта видны всем переменным, которые на него ссылаются.

### Немутируемые

Примитивные типы - это **немутируемые** значения. При изменении переменной создаётся новое значение, а не изменяется исходное.

> [!NOTE]
> 
> **Примитивные типы включают:**
> - `number`
> - `string`
> - `boolean`
> - `null`
> - `undefined`
> - `symbol`
> - `bigint`

> [!TIP]
> 
> **Как работают примитивы**
> 
> Примитивы хранят свои значения в переменных. При присваивании одной переменной значения другой создаётся копия.
> ```js
> let a = 10;
> let b = a;  // b получает копию значения a
> a = 20; // a изменяется, но b остаётся 10
> console.log(a);  // 20
> console.log(b);  // 10
> ```

### Мутируемые

Объекты (включая массивы, функции и другие структуры данных) - **мутируемые**. При присваивании объекта другой переменной обе переменные ссылаются на один и тот же объект в памяти.

> [!NOTE]
> 
> Объекты могут быть:
> 
> - `Object`
> - `Array`
> - `Function`
> - `Date`
> - `RegExp`
> - И другие

> [!TIP]
> 
> **Как работают объекты**
> 
> Объекты хранят ссылки на данные в памяти. При присваивании объекта копируется только ссылка, а не сам объект.
> ```js
> let person1 = { name: "Иван", age: 25 };
> let person2 = person1; // person2 ссылается на тот же объект
> person1.age = 30; // изменение через person1 влияет и на person2
> console.log(person2.age);  // 30
> ```
> В этом примере `person1` и `person2` ссылаются на один и тот же объект в памяти, поэтому изменение через `person1` автоматически отражается и в `person2`.

> [!TIP]
> 
> **Как сделать объект немутируемым?**
> 
> Для того чтобы объект был немутируемым, можно использовать метод `Object.freeze()`, который запрещает изменения.
> ```js
> const person = { name: "Иван", age: 25 };
> Object.freeze(person);  // замораживаем объект
> 
> person.age = 30;  // изменение не будет применено
> console.log(person.age);  // 25
> ```

## Преобразование типов
### Строковое

Иногда требуется преобразовать один тип в тип `string`.
Обычно это происходит **неявно**, например при использовании `alert(value)`.

Но мы можем использовать `String(value)` для **явного** преобразования.

```js
let value = true;
alert(typeof value); // boolean

value = String(value); // теперь 'value' это строка "true"
alert(typeof value); // string
```
### Численное

Строки с числами внутри можно преобразовывать в тип `number`.
При использовании арифметических операторов это происходит **неявно**.

```js
alert( "6" / "2" ); // 3, обе строки преобразовались в числа 6 и 2
```

Можно использовать `Number(value)` для **явного** преобразования.

```js
let str = "123";
alert(typeof str); // string

let num = Number(str); // строка "123" теперь число 123

alert(typeof num); // number
```

> [!TIP]
> 
> **Особенности численного преобразования**
> - Если `string` не может быть приведен к числу, то результатом будет `NaN`.
> ```js
> alert( Number("123cj") ); // 0
> ```
> - Если `string` пустой, то результатом будет `0`.
> ```js
> alert( Number("") ); // 0
> ```
> - Если мы преобразовываем `undefined`, то результатом будет `NaN`.
> ```js
> alert( Number(undefined) ); // NaN
> ```
> - Если мы преобразовываем `null`, то результатом будет `0`.
> ```js
> alert( Number(null) ); // 0
> ```
> - Если мы преобразовываем `true`/`false`, то результатом будет `1`/`0`.
> ```js
> alert( Number(true) ); // 1
> alert( Number(false) ); // 0
> ```

### Логическое

Происходит неявно в логических операциях, например внутри выражения `if()`.

Можно использовать `Boolean(value)` для **явного** преобразования.

```js
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("Привет!") ); // true
alert( Boolean("0") ); // true
alert( Boolean(" ") ); // true
alert( Boolean("") ); // false
```

> [!TIP]
> 
> **Особенности логического преобразования**
> 
> - "Пустые" значения такие как `0`, `null`, `undefined` и `NaN` становятся `false`.
> - Пустой `string` становится `false`.
> - Все остальные значения становятся `true`.

