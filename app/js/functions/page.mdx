---
title: Функции
slug: functions
---

## Объявление функции

> [!TIP]
> 
> `function имя ( параметры ) { тело }`

```js
function showMessage(){
    console.log("Hello, world!");
}

showMessage(); // "Hello, world!"
```

## Параметры функции

Функции могут принимать **параметры**, которые указываются в `( )`.

```js
function printMessage(message){
    console.log(message);
}

printMessage("Hello JavaScript"); // "Hello JavaScript"
printMessage("Function in JavaScript"); // "Function in JavaScript"
```

> [!NOTE]
> 
> Если **параметру** не передаётся значение при вызове функции, то он получает значение `undefined`.
> ```js
> printMessage(); // NaN (т.к. message === undefined)
> ```
> Чтобы избежать такой ситуации, можно задать **значение по умолчанию**.
> ```js
> function greet(name = "Гость") {
> 	console.log("Привет, " + name + "!");
> }
> 
> greet("Иван"); // Привет, Иван!
> greet(); // Привет, Гость!
> ```

> [!NOTE]
> 
> **Неограниченное количество параметров**
> 
> Функции могут принимать любое количество аргументов.
> Получить их можно с помощью `arguments`.
> ```js
> function sum() {
> 	let total = 0;
> 	for (let i = 0; i < arguments.length; i++) {
> 		total += arguments[i];
> 	}
> 	console.log(total);
> }
> 
> sum(1, 2, 3); // 6
> sum(10, 20); // 30
> sum(1, 2, 3, 4, 5); // 15
> ```
> Можно также использовать `...`, который собирает все аргументы в массив.
> 
> ```js
> function sum(...numbers) {
> 	let total = 0;
> 	for (let num of numbers) {
> 		total += num;
> 	}
> 	console.log(total);
> }
> 
> sum(1, 2, 3, 4); // 10
> ```
> Иногда бывает полезно использовать **параметры по умолчанию** вместе с **rest-параметрами**, чтобы задавать значения по умолчанию для недостающих аргументов и в то же время собирать остальные аргументы в массив.
> ```js
> function logMessage(message = 'Hello', ...rest) {
>   console.log(message);
>   console.log(rest);
> }
> 
> logMessage('Hi', 1, 2, 3); // "Hi", [1, 2, 3]
> logMessage(); // "Hello", []
> ```

> [!NOTE]
> 
> **Функции как аргументы**
> 
> Пример того, как функция может принимать другие функции в качестве аргументов.
> ```js
> function ask(question, yes, no) {
> 	if (confirm(question)) yes()
> 	else no();
> }
> 
> function showOk() {
> 	alert("Вы согласны");
> 	console.log("Пользователь согласился");
> }
> 
> function showCancel() {
> 	alert("Вы отменили выполнение");
> 	console.log("Пользователь отказался");
> }
> 
> // функции showOk, showCancel передаются в качестве аргументов ask
> ask("Вы согласны?", showOk, showCancel);
> ```

### Передача параметров

Примитивные типы данных (`number`, `bigint`, `string`, `boolean`, `null`, `undefined`) передаются в функцию **по значению**.

```js
let num = 10; // объявляем переменную num и присваиваем ей значение 10

function modifyNumber(n) {
	n = 20; // создаётся локальная копия аргумента n
	// изменение n не влияет на num, так как это разные переменные
}

modifyNumber(num); // передаём num в функцию
console.log(num); // 10, потому что num остался неизменным
```

> [!TIP]
> 
> **Как это работает**
> 
> Когда мы передаем `num` в функцию, создается копия значения этой переменной, и любые изменения этой копии (переменной `n`) **не затрагивают** оригинальную переменную `num` в основном коде.

---

**Объекты** (включая массивы) передаются **по ссылке**. Это означает, что внутри функции изменяется сам объект, а не его копия. Если вы измените свойства объекта внутри функции, то изменения будут видны и вне функции, так как обе переменные будут ссылаться на один и тот же объект в памяти.

```js
let person = { name: "John", age: 30 }; // создаём объект person

function modifyPerson(obj) {
  obj.age = 35; // изменяем свойство age у переданного объекта
}

modifyPerson(person); // передаём объект в функцию (ссылка остаётся той же)
console.log(person.age); // 35 (изменилось, т.к. объекты передаются по ссылке)
```

> [!TIP]
> 
> **Как это работает**
> 
> Когда мы передаем объект `person` в функцию, передается ссылка на этот объект, а не его копия. Если вы изменяете свойства объекта внутри функции, то изменения будут видны и вне функции, так как обе переменные будут ссылаться на один и тот же объект в памяти.
> Именно поэтому изменения внутри функции отражаются на исходном объекте `person`.

> [!WARNING]
> 
> **Важный момент**
> 
> Чтобы избежать изменения оригинальных данных, если это не требуется, можно создать копию объекта или массива перед передачей, используя методы клонирования (например, `Object.assign()`).

## Возврат значения

Функция может **возвращать значение** с помощью `return`.

```js
function sum(a, b) {
    return a + b; // возвращаем результат сложения
}

console.log( sum(2, 4) ); // 6

// можно также возвращать более сложные структуры данных
// например объекты или массивы
function getUserInfo() {
    return { name: "Иван", age: 30 };
	// когда функция возвращает значение, выполнение функции прекращается
	// и дальнейший код внутри этой функции не выполняется
	console.log("Это не будет выполнено"); // этот код не выполнится
}

console.log( getUserInfo() ); // { name: "Иван", age: 30 }
```

> [!NOTE]
> 
> Если `return` не указан, то функция вернет `undefined`.
> 
> ```js
> function greet(name) {
> 	console.log("Привет, " + name + "!");
> }
> 
> let result = greet("Иван");
> console.log(result); // undefined
> ```

> [!NOTE]
> 
> Функция также может возвращать другую функцию.
> 
> ```js
> function createMultiplier(multiplier) {
>     return function(num) {
>         return num * multiplier;
>     };
> }
> 
> let double = createMultiplier(2);
> console.log( double(5) ); // 10
> ```

## Область видимости переменных

- **Локальные переменные** доступны только внутри той функции, где они были объявлены. Они не видны и не могут быть использованы за пределами этой функции.

```js
function exampleFunction() {
  let localVar = 'Локальная переменная';
  console.log(localVar);  // доступно - локальная переменная
}

console.log(localVar);  // ошибка "localVar is not defined"
```

- **Глобальные переменные** доступны по всей программе.

```js
let globalVar = 'Глобальная переменная';

function exampleFunction() {
  console.log(globalVar); // доступно - глобальная переменная
}

console.log(globalVar); // доступно - глобальная переменная
```

> [!WARNING]
> 
> **Важный момент**
> 
> Глобальные переменные могут быть не только **использованы** в любой части программы, но и **изменены**, так что есть вероятность случайных изменений.

## Функции-выражения

Функции могут быть не только объявлениями, но и **выражениями**, т.е. их можно присваивать переменным или передавать как аргументы другим функциям.

```js
// объявление переменной и присваивание ей функции
const greet = function(name) {
  console.log(`Hello, ${name}!`);
}; // <- обрати внимание на ';'

// передача функции в виде параметра
function executeFunction(fn) {
  fn('world');
} // в обычной функции мы не ставим ';'

executeFunction(greet); // "Hello, world!"
```

> [!WARNING]
> 
> **Обрати внимание!**
> 
> В примере выше в конце функции `executeFunction()` у нас нет никакого `;`
> Но при объявлении переменной `greet` и присваивания ей значения в виде **функции-выражения**, мы **обязательно** ставим `;`
> 
> **Почему так?**
> 
> Потому что даже в таком случае это все равно остается выражением присваивания!
> По факту оно выглядит как `const greet = ...;`

> [!TIP]
> 
> **Особенности функций-выражений**
> 
> - Функция становится **значением** переменной, так же как и любые другие типы данных. Это позволяет передавать функции в другие функции, использовать их как аргументы и возвращать из других функций.
> - Функции-выражения могут быть **анонимными**, т.е. не иметь имени, что полезно в случае, когда функция используется однократно или в контексте других операций.
> ```js
> // анонимная функция
> const sum = function(a, b) {
>   return a + b;
> };
> 
> console.log(sum(3, 4)); // 7
> ```
> - Функции-выражения часто используются как **аргументы** в другие функции.
> ```js
> // передача анонимной функции
> setTimeout(function() {
>   console.log("Время прошло!");
> }, 1000);
> ```
> - Функции-выражения могут быть **возвращены** из других функций.
> ```js
> function createAdder(x) {
>   return function(y) {
>     return x + y;
>   };
> }
> 
> const add5 = createAdder(5);
> console.log(add5(10)); // 15
> ```

## Стрелочные функции

Стрелочные функции это просто краткий синтаксис для написания функций.

```js
// обычная функция
function add(a, b) {
  return a + b;
}

// стрелочная функция
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5
```

> [!TIP]
> 
> **Особенности стрелочных функций**
> 
> - Стрелочные функции не требуют ключевого слова `return`, если функция состоит из одного выражения, и автоматически возвращает результат.
> ```js
> const square = x => x * x;
> console.log(square(4)); // 16
> ```
> - В отличие от обычных функций, стрелочные функции не имеют собственного контекста `this`. Вместо этого они используют `this` из окружающего контекста.
> ```js
> // обычная функция
> function Person(name) {
>     this.name = name;
>     setTimeout(function() {
>         console.log(this.name); // undefined, так как `this` относится к setTimeout
>     }, 1000);
> }
> 
> new Person("Иван");
> 
> // стрелочная функция
> function Person2(name) {
>     this.name = name;
>     setTimeout(() => {
>         console.log(this.name); // Иван, стрелочная функция использует внешний `this`
>     }, 1000);
> }
> 
> new Person2("Иван");
> ```
> - Стрелочные функции не могут быть использованы как конструкторы, и попытка вызвать стрелочную функцию с `new` вызовет ошибку.
> ```js
> const func = () => {};
> const obj = new func(); // TypeError: func is not a constructor
> ```
> - Стрелочные функции не имеют объекта `arguments`, который доступен в обычных функциях для доступа к переданным параметрам.
> ```js
> const example = () => {
>     console.log(arguments); // ReferenceError: arguments is not defined
> };
> example(1, 2, 3); 
> ```

> [!TIP]
> 
> **Когда использовать стрелочные функции?**
> 
> Стрелочные функции особенно удобны в следующих случаях:
> 
> - Коллбэки - передача функций в `map`, `filter`, `reduce` и другие методы.
> - Методы внутри классов - если нужно сохранить контекст `this`.
> - Короткие выражения - когда функция выполняет простое действие и не требует тела `{}`.

## Замыкания

Замыкание это функция, которая "запоминает" своё окружение (т.е. переменные), доступные на момент её создания, даже после того, как внешняя функция завершит своё выполнение.
Это свойство позволяет функции продолжать доступ к переменным, определённым в её внешнем контексте.

```js
function outer() {
  let count = 0;  // локальная переменная внешней функции
  // внутренняя функция "inner" является замыканием
  return function inner() {
    count++; // доступ к переменной count из внешней функции
    console.log(count); // выводим обновлённое значение count
  };
}

const counter = outer();  // вызов outer() возвращает функцию inner, которая сохраняет доступ к count
counter(); // 1
counter(); // 2
```

> [!TIP]
> 
> **Объяснение**
> 
> - Внутренняя функция `inner` имеет доступ к переменной `count`, которая находится в её замкнутой области видимости (т.е. области видимости функции `outer`).
>- Каждый раз, когда вызывается функция `counter()`, она изменяет значение переменной `count`, даже несмотря на то, что внешняя функция `outer` уже завершила выполнение.
> - Как итог, замыкания позволяют сохранять состояние между вызовами функции.

> [!NOTE]
> 
> **Дополнительные примеры и применения замыканий**
> 
> - Замыкания часто используются для создания "частных" переменных или функций, которые могут сохранять состояние между вызовами.
> - В этом примере, `counter1` и `counter2` - это два разных замыкания, каждый из которых хранит своё собственное значение `count`, независимо от другого.
> ```js
> function makeCounter() {
>   let count = 0;
>   return function() {
>     return count++; // инкрементируем переменную count при каждом вызове
>   };
> }
> 
> const counter1 = makeCounter();
> console.log(counter1()); // 0
> console.log(counter1()); // 1
> 
> const counter2 = makeCounter();
> console.log(counter2()); // 0
> ```
> - Замыкания могут быть полезны для создания **приватных переменных**, доступных только через методы.
> ```js
> function createUser(name, age) {
>   let userName = name; // приватная переменная
>   let userAge = age; // приватная переменная
> 
>   return {
>     getName: function() {
>       return userName;
>     },
>     getAge: function() {
>       return userAge;
>     },
>     setAge: function(newAge) {
>       if (newAge > 0) {
>         userAge = newAge; // меняем приватную переменную через метод
>       }
>     }
>   };
> }
> 
> const user = createUser("John", 25);
> console.log(user.getName()); // John
> console.log(user.getAge()); // 25
> user.setAge(26);
> console.log(user.getAge()); // 26
> ```
> - Замыкания полезны в **асинхронных функциях**, где важно сохранить контекст (например, переменные) в момент вызова, даже если выполнение функции будет продолжено позже.
> ```js
> function fetchData(url) {
>   let requestTime = Date.now();
>   return function() {
>     console.log(`Запрос к ${url} был сделан в ${requestTime}`);
>   };
> }
> 
> const logRequest = fetchData('https://example.com');
> setTimeout(logRequest, 1000); // через 1 секунду выводит время запроса
> ```

> [!WARNING]
> 
> Замыкания - мощный инструмент, но их неправильное использование может привести к **утечкам памяти** и **падению производительности**.
> Стоит быть особенно осторожным при создании долговременных ссылок на замыкания в больших приложениях и использовании их в асинхронном коде, чтобы избежать накопления ненужных данных в памяти.

## Функции IIFE

**IIFE** (Immediately Invoked Function Expression) это **самовызывающаяся функция**, которая выполняется сразу же после своего объявления.

В этом примере функция не только объявляется, но и сразу же вызывается, благодаря добавлению `( )` после её определения:

```js
(function() {
  console.log("Hello, world!");
})(); // функция выполняется сразу после её объявления
// "Hello, world!"

// можно также задавать параметры
(function(a, b) {
  console.log(`Результат умножения: ${a * b}`);
})(3, 4);
// "Результат умножения: 12"
```

> [!NOTE]
> 
> **Параметры в IIFE**
> 
> В самовызывающуюся функцию можно передавать **параметры**, как и в обычную функцию. Это позволяет выполнять операции с переданными значениями без загрязнения внешней области видимости.
> 
> ```js
> (function(a, b) {
>   const result = a + b;
>   console.log(`${a} + ${b} = ${result}`);
> })(4, 5); // сразу передаем параметры функции
> // 4 + 5 = 9"
> ```

> [!TIP]
> 
> **Где это может быть полезно?**
> 
> IIFE удобны для инициализации данных, скрытия переменных от глобальной области видимости и единовременного выполнения кода.
> Например, они применяются для настройки конфигурации, создания модулей, а также в коде, который должен выполниться сразу при загрузке, но не повторяться в будущем.

## Рекурсивные функции

**Рекурсия** это процесс, при котором функция вызывает сама себя для решения задачи. Это мощный инструмент, который особенно полезен при решении задач, разбиваемых на более простые подзадачи.

Рекурсия часто применяется для работы с иерархическими структурами (деревьями, графами), решения математических задач (например, вычисление факториала) или при обработке повторяющихся вычислений.

> [!WARNING]
> 
> **Важный момент**
> Каждая рекурсивная функция должна иметь условие выхода, иначе она вызовет переполнение стека и приведёт к ошибке (stack overflow).
> Исключение - случаи, когда функция должна выполняться бесконечно (например, серверный цикл обработки запросов).

**Пример: вычисление факториала**

Факториал числа 𝑛 обозначается как 𝑛! и вычисляется по следующему принципу:

`n!=n×(n−1)×(n−2)×⋯×1`


В рекурсивном подходе это можно выразить так:

```js
function factorial(n) {
  if (n === 1) { // Условие выхода
    return 1;
  }
  return n * factorial(n - 1); // Рекурсивный вызов
}

console.log(factorial(5)); // 120
```

> [!TIP]
> 
> **Объяснение**
> 1. Функция `factorial(5)` вызывает `factorial(4)`.
> 2. Функция `factorial(4)` вызывает `factorial(3)`, и так далее.
> 3. Когда `factorial(1)` вызывается, срабатывает условие выхода, и возвращается `1`, который затем передается обратно через все рекурсивные вызовы, умножаясь на соответствующие числа.

## Переопределение функций

В JavaScript функции являются **объектами первого класса**, что позволяет присваивать их переменным, передавать в другие функции и изменять после определения. Это делает возможным их переопределение.

> [!TIP]
> 
> **Как это работает**
> 
> При присваивании функции переменной создаётся ссылка на неё. Это позволяет изменять поведение функции, подменяя её новым определением.

```js
let greet = function() {
  console.log('Привет!');
};

greet(); // "Привет!"

// переопределение функции внутри переменной
greet = function() {
  console.log('Здравствуйте!');
};

greet(); // "Здравствуйте!"
```

> [!NOTE]
> 
> Переопределять можно не только функции, записанные в переменные, но и методы объектов, а также встроенные функции и прототипы.

```js
function greet() {
  console.log('Привет!');
}

greet(); // "Привет!"

// переопределение функции
greet = function() {
  console.log('Здравствуйте!');
};

greet(); // "Здравствуйте!"
```

> [!TIP]
> 
> **Где это может быть полезно?**
> 
>Переопределение функций удобно, когда нужно адаптировать поведение кода в зависимости от условий, например:
> 
> - Изменение функций в зависимости от окружения (разработка/продакшн).
> - Замена функции после первого вызова для повышения производительности.
> - Исправление или расширение поведения встроенных функций и методов.