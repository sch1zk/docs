---
title: Promise, async и await
---

## `Promise`

`Promise` это объект, представляющий результат асинхронной операции, которая ещё не завершена, но в будущем может быть выполнена успешно или с ошибкой. Он помогает работать с асинхронным кодом, предотвращая "ад колбеков" и улучшая читаемость кода.

### Создание `Promise`

`Promise` создаётся через конструктор, который принимает функцию с двумя аргументами:
- `resolve` - вызывается при успешном завершении операции.
- `reject` - вызывается при возникновении ошибки.

```js
let promise = new Promise(function(resolve, reject) {
	let success = true;

	if (success) {
		resolve("Операция прошла успешно");
	} else {
		reject("Произошла ошибка");
	}
});
```

> [!NOTE]
> 
> Каждый вызов `then()` возвращает новый `Promise`, что позволяет строить цепочки асинхронных операций. Это даёт возможность последовательно обрабатывать результаты или ошибки:
> ```js
> let chain = new Promise(resolve => resolve(1));
> 
> chain
> 	.then(result => result + 2) // 1 + 2 = 3
> 	.then(result => result * 3) // 3 * 3 = 9
> 	.then(result => console.log(result)); // 9
> ```

> [!WARNING]
> 
> Если не обработать ошибку с `catch()`, может возникнуть необработанное исключение.
> ```js
> let promise = new Promise((resolve, reject) => reject("Произошла ошибка"));
> 
> promise
> 	.then(result => console.log(result))
> 	.catch(error => console.log(error)); // важно: обработка ошибки с .catch()
> ```

> [!WARNING]
> 
> Не забывайте внимательно следить за асинхронными операциями, чтобы избежать ситуации, когда `Promise` остаётся в состоянии ожидания (например, при сетевых запросах или длительных вычислениях).
### Состояния `Promise`

`Promise` может быть в одном из трёх состояний:
- **Pending:** Ожидание результата.
- **Resolved (fulfilled):** Успешное завершение.
- **Rejected:** Ошибка.

### Методы обработки Promise
#### `then()`

Метод `then()` используется для обработки успешного завершения `Promise`.

```js
promise
	.then(result => {
		console.log(result); // "операция прошла успешно"
	});
```
#### `catch()`

Обрабатывает ошибку, если Promise был отклонён.

```js
promise
	.then(result => {
		console.log(result);
	})
	.catch(error => {
		console.log(error); // "Произошла ошибка"
	});
```

#### `finally()`

Выполняется всегда после завершения, независимо от успеха или ошибки.

```js
promise
	.then(result => {
		console.log(result);
	})
	.catch(error => {
		console.log(error);
	})
	.finally(() => {
		console.log("Операция завершена"); // выполняется всегда
	});
```

## `async` и `await`

`async` и `await` - это синтаксические конструкции в JavaScript, которые упрощают работу с асинхронным кодом. Они позволяют писать асинхронные операции, как обычные синхронные функции, улучшая читаемость и упрощая обработку ошибок.

> [!NOTE]
> 
> Преимущества `async`/`await`
> 
> - Код с использованием `async`/`await` выглядит как синхронный, что облегчает понимание и поддержку.
> - Вместо использования цепочек `.then()` и `.catch()`, `async`/`await` позволяет работать с асинхронными задачами последовательно, как с обычным кодом.

> [!WARNING]
> 
> **Важные моменты**
> 
> - Использовать `await` можно только внутри функции, помеченной как `async`. Вне таких функций он вызовет ошибку.
> - Если `async` функция возвращает значение, оно автоматически оборачивается в `Promise.resolve()`. Поэтому даже если функция возвращает просто строку или число, это будет `Promise`.
> - Ошибки, возникающие внутри `await` или в самом процессе асинхронной работы, автоматически отклоняют `Promise`. Эти ошибки можно перехватывать с помощью `try`/`catch`.
### `async`

`async` используется для объявления функции как асинхронной.

```js
async function fetchData() {
  return "Данные загружены"; // эта строка возвращает 'Promise', обернув значение.
}

fetchData().then(result => console.log(result)); // "Данные загружены"
```

> [!WARNING]
> 
> Важно помнить, что функция, помеченная `async`, всегда возвращает `Promise`!
> Если функция возвращает значение, оно будет автоматически обёрнуто в `Promise`, а если функция выбрасывает ошибку, она будет отклонена, как `Promise` с ошибкой.
### `await`

`await` используется внутри асинхронной функции для ожидания выполнения `Promise`.

```js
async function fetchData() {
	let response = await new Promise(resolve => setTimeout(() => resolve("Данные загружены"), 2000));
	console.log(response); // "Данные загружены"
}

fetchData();
```

> [!TIP]
> 
> **Как это работает**
> 
> Когда `await` встречает `Promise`, выполнение функции приостанавливается до завершения `Promise` вне зависимости от того, будет ли он выполнен успешно или с ошибкой. После этого результат `Promise` становится доступен, и выполнение функции продолжается.

### Обработка ошибок с `try`/`catch`

`async`/`await` позволяет использовать стандартный механизм обработки ошибок с помощью блока `try`/`catch`, что упрощает работу с исключениями при асинхронных операциях.

```js
async function fetchData() {
  try {
    let response = await new Promise((resolve, reject) => reject("Ошибка загрузки"));
    console.log(response);
  } catch (error) {
    console.log("Произошла ошибка:", error); // "Произошла ошибка: Ошибка загрузки"
  }
}

fetchData();
```

### Сочетание с другими асинхронными операциями

`async`/`await` хорошо работает в сочетании с другими асинхронными методами, такими как `Promise.all()`, `Promise.race()`, `Promise.allSettled()` и `Promise.any()`. Эти методы позволяют выполнять несколько асинхронных операций параллельно и эффективно управлять их завершением.

#### `Promise.all()`

`Promise.all()` позволяет запускать несколько асинхронных операций параллельно и ожидать их завершения. Он принимает массив промисов и возвращает новый `Promise`, который разрешается, когда все переданные промисы успешно завершаются. Если хотя бы один из промисов будет отклонён, весь `Promise.all()` будет отклонён.

```js
async function fetchData() {
	let promise1 = new Promise(resolve => setTimeout(resolve, 1000, "Данные 1"));
	let promise2 = new Promise(resolve => setTimeout(resolve, 2000, "Данные 2"));
	
	// ожидаем завершения всех промисов
	let results = await Promise.all([promise1, promise2]);
	console.log(results);  // ["Данные 1", "Данные 2"]
}

fetchData();
```

> [!WARNING]
> 
> **Важный момент**
> 
> `Promise.all()` следует использовать, когда важно дождаться завершения всех операций. Если хотя бы один промис завершится с ошибкой, весь результат будет отклонён, и остальные промисы будут проигнорированы.
> 
#### Promise.race()

`Promise.race()` возвращает новый `Promise`, который будет разрешён или отклонён, как только один из переданных промисов завершится, независимо от того, завершится ли он успешно или с ошибкой. Это полезно в ситуациях, когда важно дождаться завершения первого из нескольких промисов, и не имеет значения, завершится ли он с результатом или ошибкой.

```js
async function fetchData() {
  let promise1 = new Promise(resolve => setTimeout(resolve, 1000, "Данные 1"));
  let promise2 = new Promise(resolve => setTimeout(resolve, 2000, "Данные 2"));
  
  let result = await Promise.race([promise1, promise2]);
  console.log(result);  // "Данные 1" (поскольку первый промис завершится первым)
}

fetchData();
```

> [!NOTE]
> 
> `Promise.race()` используется, когда нужно дождаться завершения только одного промиса, независимо от того, завершится ли он успешно или с ошибкой. Это полезно для реализации тайм-аутов, проверки первого отклика от нескольких источников или выбора первого завершённого запроса.

#### `Promise.allSettled()`

`Promise.allSettled()` позволяет ожидать завершения всех переданных промисов, независимо от того, завершатся ли они успешно или с ошибкой. Он возвращает массив объектов, где каждый объект описывает результат выполнения соответствующего промиса.

```js
async function fetchData() {
  let promise1 = new Promise(resolve => setTimeout(resolve, 1000, "Данные 1"));
  let promise2 = new Promise((resolve, reject) => setTimeout(reject, 2000, "Ошибка"));

  let results = await Promise.allSettled([promise1, promise2]);
  console.log(results); 
  // [
  //   { status: "fulfilled", value: "Данные 1" },
  //   { status: "rejected", reason: "Ошибка" }
  // ]
}

fetchData();
```

> [!NOTE]
> 
> `Promise.allSettled()` полезен, когда нужно обработать все промисы, независимо от того, завершатся ли они успешно или с ошибкой.

#### `Promise.any()`

`Promise.any()` возвращает первый успешно завершившийся промис из переданных, игнорируя те, которые завершились с ошибкой. Если все промисы отклонены, то `Promise.any()` отклоняется с ошибкой `AggregateError`, которая содержит массив всех ошибок отклонённых промисов.

Это полезно, когда нужно получить результат первого успешно выполненного промиса из нескольких, независимо от того, сколько промисов завершатся с ошибкой.

```js
async function fetchData() {
  let promise1 = new Promise((resolve, reject) => setTimeout(reject, 1000, "Ошибка 1"));
  let promise2 = new Promise((resolve, reject) => setTimeout(resolve, 2000, "Данные 2"));
  
  let result = await Promise.any([promise1, promise2]);
  console.log(result);  // "Данные 2"
}

fetchData();
```

> [!NOTE]
> 
> `Promise.any()` полезен, когда нужно получить результат первого успешно выполненного промиса из нескольких.